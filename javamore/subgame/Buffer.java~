/*<applet code="SubKillerGame.class" width=500 height=500></applet>*/import java.awt.*;        // for access to GUI classesimport java.awt.event.*;  // for access to the KeyEvent classpublic class Buffer extends JApplet implements ActionListener, KeyListener, FocusListener, MouseListener {		   public void mouseEntered(MouseEvent evt) { }  // Required by the	   public void mouseExited(MouseEvent evt) { }   //    MouseListener	   public void mouseReleased(MouseEvent evt) { } //       interface.	   public void mouseClicked(MouseEvent evt) { }	   	   	 public void focusGained(FocusEvent evt) {         // The applet now has the input focus. Set focussed = true         // start the animation.      focussed = true;      startAnimation();   }			protected void doInitialization(int width, int height) {             initBall(width, height);               } // end doInitialization()        public void start() {           // Called by the system when the applet is first started            // or restarted after being stopped.  (Probably this has           // no effect, since we shouldn't get forcus events before           // the applet is started.)      startAnimation();   }      public void stop() {           // Called by the system to suspend the applet.       stopAnimation();   }   public void focusLost(FocusEvent evt) {         // The applet has lost the input focus. Set focussed = false         // and stop the animation.      stopAnimation();      focussed = false;   }      public void mousePressed(MouseEvent evt) {        // Request the input focus when the user clicks on        // the applet.      frame.requestFocus();   }      protected void drawFrame(Graphics g, int width, int height) {      g.setColor(Color.lightGray);      g.fillRect(0,0,width,height);      g.setColor(Color.black);      g.drawString("Elapsed Time:  " + (getElapsedTime()/1000),10,20);      g.drawString("Frame Number:  " + (getFrameNumber()),10,35);   }	   protected void doInitialization(int width, int height) {             initBall(width, height);               } // end doInitialization()   public void keyTyped(KeyEvent evt) {          // Method to respond when the user types a character.  Use         // char key = evt.getKeyChar() to find out which character         // was typed.  Note that this method is part of the         // KeyListener interface.   }      public void keyPressed(KeyEvent evt) {          // Method to respond to key presses.  Use int code = evt.getKeyCode() to         // get a code number for the key pressed.  The value of this code         // is given by constants in the KeyEvent class such as KeyEvent.VK_LEFT         // for the left arrow key and KeyEvent.VK_X for the "X" key.  Override this         // method if you want to respond when the user presses special keys like          // the arrow keys.  Note that this routine is part of the KeyListener         // interface   }      public void keyReleased(KeyEvent evt) {          // Method to respond when the user releases a key. Use evt.getKeyCode()         // to get the code number of the key that was released.  Override this         // method if you want to respond when the user releases a key.  This method         // is part of the KeyListener interface.   }      public int getFrameNumber() {         // Get the current frame number.  The frame number will be incremented         // each time a new frame is to be drawn.  The first frame number is 0.         // (If frameCount is greater than zero, and if frameNumber is greater than         // or equal to frameCount, then frameNumber returns to 0.)  For a keyboard         // applet, you are not too likely to need frame numbers, actually.      return frameNumber;   }      public void setFrameNumber(int frameNumber) {           // Set the current frame number.  This is the value returned by getFrameNumber().      if (frameNumber < 0)         this.frameNumber = 0;      else         this.frameNumber = frameNumber;         }      public long getElapsedTime() {           // return the total number of milliseconds that the animation has been           // running (not including the time when the applet is suspended by           // the system or when the applet does not have the keyboard focus).      return elapsedTime;   }      public void setFrameCount(int max) {           // If you want your animation to loop through a set of frames over           // and over, you should call this routine to set the frameCount to            // the number of frames in the animation.  Frames will be numbered           // from 0 to frameCount - 1.  If you specify a value <= 0, the           // frameNumber will increase indefinitely without ever returning           // to zero.  The default value of frameCount is -1, meaning that           // by default frameNumber does NOT loop.      if (max <= 0)         this.frameCount = -1;      else          frameCount = max;   }      public void setMillisecondsPerFrame(int time) {           // Set the approximate number of milliseconds to be used for each frame.           // For example, set time = 1000 if you want each frame to be displayed for           // about a second.  The time is only approximate, and the actual display           // time will probably be a bit longer.  The default value of 40 is           // probably OK for a game.      millisecondsPerFrame = time;      if (timer != null)         timer.setDelay(millisecondsPerFrame);   }      public void setFocusBorderColor(Color c) {            // Set the color of the three-pixel border that surrounds the applet            // when the applet has the keyboard focus. The default color is cyan.            // Note:  The color of the frame when the applet does NOT have the            // focus is taken from the background color of the applet, which            // is gray by default.  The color of the message "Click to activate",            // which is displayed when the applet does not have focus, is taken            // from the foreground color of the applet, and is red by default.      focusBorderColor = c;   }      // This rest of this file is private stuff that you don't have to know about   // when you write subclasses of this class.   private int frameNumber = 0;            // Current frame number.   private int frameCount = -1;            // If > 0, frame number loops from                                           //   frameNumber-1 back to 0.   private int millisecondsPerFrame = 40;  // Approximate time between frames.      private long startTime;       // Time since animation was started or restarted.   private long oldElapsedTime;  // Holds time the animation had been running before                                 //    it was most recently restarted.   private long elapsedTime;     // Time animation has been running.  This is set                                 //    just before each frame is drawn.   private Timer timer;   // The timer that drives the animation.      private JPanel frame;  // Where the frames are drawn.  This panel fills the applet.      private boolean focussed = false;  // set to true when the applet has the keyboard focus      Color focusBorderColor = Color.cyan;  // Color of border when applet has the focus.      public KeyboardAnimationApplet2() {        frame = new JPanel() {            public void paintComponent(Graphics g) {               int width = getSize().width;               int height = getSize().height;               drawFrame(g,width,height);               if (focussed)                     // Draw a 3-pixel border.  If the applet has the                  g.setColor(focusBorderColor);  //   focus, draw it in focusBorderColor; otherwise,               else                              //   draw it in the background color.                  g.setColor(KeyboardAnimationApplet2.this.getBackground());               g.drawRect(0,0,width-1,height-1);               g.drawRect(1,1,width-3,height-3);               g.drawRect(2,2,width-5,height-5);               if (!focussed) { // If the applet does not have the focus,                                 // print a message for the user.                  g.setColor(KeyboardAnimationApplet2.this.getForeground());                  g.drawString("Click to activate",10,height-12);               }            }         };      setContentPane(frame);      setBackground(Color.gray); // Color used for border when applet doesn't have focus.      setForeground(Color.red);      frame.setFont(new Font("SanSerif",Font.BOLD,14));      frame.addFocusListener(this);      frame.addKeyListener(this);      addMouseListener(this);   }      public void init() {        // Just call do initialization.  (This is in init() instead of in        // the constructor since the size of the applet is not known in the        // constructor.)      doInitialization(getSize().width, getSize().height);   }      public void actionPerformed(ActionEvent evt) {         // Called by the timer when it's time to draw a new frame.      frameNumber++;      if (frameCount > 0 && frameNumber >= frameCount)         frameNumber = 0;      elapsedTime = oldElapsedTime + (System.currentTimeMillis() - startTime);      frame.repaint();   }         private void startAnimation() {         // Start or restart the animation, but only if the applet has focus.      if (focussed) {          if (timer == null) {             timer = new Timer(millisecondsPerFrame, this);             timer.start();          }          else             timer.restart();         startTime = System.currentTimeMillis();      }   }      private void stopAnimation() {         // Start the animation, if it's running, i.e. if the applet has focus.      if (focussed) {         oldElapsedTime += (System.currentTimeMillis() - startTime);         elapsedTime = oldElapsedTime;         frame.repaint();         timer.stop();      }   }   synchronized public void drawFrame(Graphics g, int width, int height) {                       g.setColor(Color.green);       g.fillRect(0,0,width,height);              doSubmarineFrame(g, width, height);              } // end drawFrame()         synchronized public void keyPressed(KeyEvent evt) {      } // end keyPressed()        // -------------- Instance variables and method for the submarine -------------      int subCenterX;  // Horizontal coordinate of the center of the submarine.   int subCenterY;  // Vertical coordinate of the center of the submarine.      boolean subIsMovingLeft;  // Sub can be moving left or right; this variable tells which.      void initBall(int width, int height) {        subCenterX = (int)(width * Math.random());      subCenterY = height - 40;      explosionFrameNumber = 0;      if (Math.random() < 0.5)         subIsMovingLeft = true;      else         subIsMovingLeft = false;   }      void doSubmarineFrame(Graphics g, int width, int height) {       if (explosionFrameNumber > 0) {         if (explosionFrameNumber == 14) {  // In the 14-th frame...            initBall(width,height);    //    ... create a new sub (also sets explosionFrameNumber to 0)         }                     else if (explosionFrameNumber > 10) { // For frames 11, 12, and 13,                                               //   there is no sub             explosionFrameNumber++;  // Just go to next frame of explosion sequence         }                  else {  // For frames 1 through 10, draw the sub under an expanding explosion            g.setColor(Color.black);            g.fillOval(subCenterX - 30, subCenterY - 15, 60, 30);            g.setColor(Color.yellow);            g.fillOval(subCenterX - 4*explosionFrameNumber,                       subCenterY - 2*explosionFrameNumber,                       8*explosionFrameNumber,                       4*explosionFrameNumber);            g.setColor(Color.red);            g.fillOval(subCenterX - 2*explosionFrameNumber,                       subCenterY - explosionFrameNumber/2,                       4*explosionFrameNumber,                       explosionFrameNumber);            explosionFrameNumber++;  // Go on to next frame of explosion.         }                  }                  else { // Sub is not exploding.  Move the sub and draw it in its new position               if (Math.random() < 0.04)               // One time out of 25, on average...            subIsMovingLeft = !subIsMovingLeft;  //   ...randomly reverse direction                     if (subIsMovingLeft) {             subCenterX -= 5;        // Move the sub left 5 pixels.            if (subCenterX <= 0) {  // If sub has moved off left hand edge of applet...               subCenterX = 0;      //       ...move it back to the left edge...               subIsMovingLeft = false; //  ...and start it moving right.            }         }         else {            subCenterX += 5;           // Move the sub right 5 pixels.            if (subCenterX > width) {  // If the sub has moved off the right edge...               subCenterX = width;     //    ...move it back to the right edge...               subIsMovingLeft = true; //    ...and start it moving left.            }         }         g.setColor(Color.black);  // Draw the sub         g.fillOval(subCenterX - 30, subCenterY - 15, 60, 30);      }   }  // end doSubmarineFrame       } // end class SubKiller//////////////////////////////////////////////////////////////////////////////